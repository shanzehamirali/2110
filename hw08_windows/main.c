#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
#include "images/prince.h"
#include "images/slipper.h"
#include "images/start.h"
#include "images/win.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  int time = 0;
  char charArray[20];
  struct Prince player;
  struct Slipper shoe;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state) {
      case START:
        player.row = 0;
        player.column = 160 - PRINCE_HEIGHT;
        shoe.row = 157;
        shoe.column = 128;
        drawFullScreenImageDMA(start);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
            drawRectDMA(0, 0, 240, 160, GRAY);
            vBlankCounter = 0;
            state = PLAY;
        }
        break;
      case PLAY:
        drawRectDMA(player.column, player.row, PRINCE_WIDTH, PRINCE_HEIGHT, MAGENTA);
        if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
            if (player.row < 210) {
                player.row++;
            }
        }
        if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
            if (player.row > 0) {
                player.row--;
            }
        }
        if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
            if (player.column < 160 - PRINCE_HEIGHT) {
                player.column++;
            }
        }
        if (KEY_DOWN(BUTTON_UP, currentButtons)) {
            if (player.column > 0) {
                player.column--;
            }
        }
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        }
        if (player.row + PRINCE_HEIGHT >= shoe.row && player.row <= shoe.row + SLIPPER_HEIGHT
            && player.column <= shoe.column + SLIPPER_WIDTH && player.column + PRINCE_WIDTH >= shoe.column) {
            state = WIN;
        }
        drawImageDMA(player.column, player.row, PRINCE_WIDTH, PRINCE_HEIGHT, prince);
        drawImageDMA(shoe.column, shoe.row, SLIPPER_WIDTH, SLIPPER_HEIGHT, slipper);
        waitForVBlank();
        drawRectDMA(0,0, 50, 10, BLACK);
        snprintf(charArray, 20, "TIME: %d", time);
        drawString(0,0, charArray, WHITE);
        time = vBlankCounter / 60;

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        }
        break;
      case WIN:
        drawFullScreenImageDMA(win);
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
            state = START;
        }
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}

//video buffer stores everything in a single array.
//uint16_t videobuffer[]; // array of 16 bit integer (because color is 16 bits)
//  videoBuffer(row, col) = videobuffer + (row * WIDTH + col);
// Every iteration of the changes of the video buffer is call a draw cycle
//we separate a draw cycle into two steps, vdraw and vblank. During vdraw, the
//  line-by-line drawing is performed. During vblank, nothing is done to the screen. Therefore, if the video
//  buffer is updated during vblank, no tearing will occur.
 Thus, we always wait for scanline to reach the start
//  of the next vblank before making any new changes to the video buffer
// scanline is between greater then 160 or not. To do this, we write
//   #define SCANLINECOUNTER *(volatile unsigned short *) 0x4000006
// > 160 = vblank

//Source REgister: pointer to array of pixel values
//This is going to be the source address of what we are copying. In general, we usually have two cases for this:
  1. Drawing an image rectangle
  2. Drawing a color rectangle
//  we only ever use the address of a variable (in this case color), and never use the value of the variable, the
//  compiler tries to be smart and efficient and never actually initializes the variable, so we would always draw
//  the color black (value of 0).
//  We use the volatile keyword. It tells the compiler to avoid optimizing this variable, so this optimization
//  mentioned above never happens. As a result, it will properly initialize the color variable and we can draw
//  correctly. So, when using DMA with a color, the color parameter must ALWAYS be declared volatile

//DR : video buffer

//CR:
//On/Off
  2. How many elements to copy over
  3. How to iterate through the destination
  4. How to iterate through the source
//#define DMA ((volatile DMA_CONTROLLER *) 0x040000B0)
//#define BUTTONS *(volatile u32 *) 0x4000130
//#define KEY_DOWN(key, buttons) (~(buttons) & (key))
  #define KEY_JUST_PRESSED(key, buttons, oldbuttons)
  (KEY_DOWN(key,buttons)&& !KEY_DOWN(key,oldbuttons))
  set pixel row 6 col 4 to black: *(vb + (6*240) + 4) = x0000

//copy image to vb: DMA_SRC_INC | DMA DEST INC | DMA_ON | 160*240